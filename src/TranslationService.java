import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;

import static java.lang.Character.isUpperCase;
import static java.lang.Character.toUpperCase;


public class TranslationService {


        public static String Translate(String input) {
            HashSet<String> names = ReadNames();
            String translatedSentence = "";
            String currentWord = "";

            String[] inputArray = input.split("((?<=\\\\s)|(?=\\\\s))|((?<=[^a-zA-Zæøåòèê0-9])|(?=[^a-zA-Zæøåòèê0-9]))"); // Generated by Gemini

            HashMap<String, String> translations = ReadTranslations();

            int wordIndex = 0;
            for (String word : inputArray) {
                boolean capital = false;
                if (isUpperCase(word.charAt(0))) {
                    capital = true;
                }
                currentWord = translations.getOrDefault(word.toLowerCase(), word); // If there is a match, it will be translated. If not, it will stay the same.

            /*
            If the current word ends in an s, it might be a possessive s. In that case,
            I check if the thing before the s exists in the name hashset. If it does, it is, in fact a name with a possessive s,
            and will be passed to the cleaner for that case.

             */
//                if (currentWord.charAt(currentWord.length() - 1) == 's') {
//                    if (names.contains(currentWord.substring(0, currentWord.length() - 2))) {
//                        RemovePossessive(currentWord, inputArray, wordIndex); // ************************************
//                    }
//                }

                if (capital) {
                    currentWord = toUpperCase(currentWord.charAt(0)) + currentWord.substring(1);
                }
                translatedSentence += currentWord;
                wordIndex++;
            }
            return translatedSentence;
        }


        public static HashSet<String> ReadNames() {
            HashSet<String> names = new HashSet<String>();


            try (BufferedReader reader = new BufferedReader(new FileReader("src/names.txt"))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    if (line.trim().isEmpty()) {
                        continue;
                    }

                    String[] words = line.trim().split("\\s+");

                    for (String word : words) {
                        if (word != null && !word.isEmpty()) {
                            names.add(word);
                        }
                    }
                }
            } catch (IOException e) {
                System.err.println("Error reading file: " + e.getMessage());
            }
            return names;
        }

        public static HashMap<String, String> ReadTranslations() {
            HashMap<String, String> translations = new HashMap<>();

            try (BufferedReader reader = new BufferedReader(new FileReader("src/translation.csv"))) {
                String line;

                while ((line = reader.readLine()) != null) {
                    if (line.trim().isEmpty()) {
                        continue;
                    }
                    String[] pair = line.split(",");

                    translations.put(pair[0], pair[1]);
                }
            } catch (IOException ex) {
                throw new RuntimeException(ex);
            }
            return translations;
        }

        private void RemovePossessive(String currentWord, String[] inputArray, int wordIndex) {
            currentWord = currentWord.substring(0, currentWord.length() - 2); // Remove the possessive

        /*
            Pseudocode:
            Send inputArray[wordIndex]+1 to the API. If it is a noun, it will take the gender and get sin/si/sitt/sine
            If it is not (for example Håvards store katter, go to the next word and do the same.


         */
        }

}