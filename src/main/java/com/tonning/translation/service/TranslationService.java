// Functions for translating from Bokmål to Nynorsk based on preprocessed translations and rules
package com.tonning.translation.service;
import org.springframework.stereotype.Service;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import static java.lang.Character.isUpperCase;
import static java.lang.Character.toUpperCase;

@Service
public class TranslationService {
    public static String Translate(String input) {
        HashSet<String> names = ReadNames(); // Creates hashset with most common Norwegian names
        HashMap<String, String[]> dictionary = ReadDict(); // Bokmål dictionary
        HashMap<String, String> nnDict = ReadNNDict(); // Nynorsk dictionary
        HashMap<String, String> translations = ReadTranslations(); // Mapping with translations
        String currentWord;
        StringBuilder finalSentence = new StringBuilder();

        // The input word is split on any non-standard Norwegian character, such as punctuation or space. These characters are still kept in the array for later reconstruction
        String[] inputArray = input.split("((?<=\\\\s)|(?=\\\\s))|((?<=[^a-zA-Zæøåòèê0-9])|(?=[^a-zA-Zæøåòèê0-9]))"); // Generated by Gemini

        int wordIndex = 0;
        for (String word : inputArray) {

            // If it ends in an s, it might be a possessive. To find out, we need to check if it is still a word (or name) when the s is removed
            if (word.charAt(word.length() - 1) == 's' && word.length() >= 2) {

                // We also need to check that the word is a noun, because some verbs get s-endings
                // There are also some hard coded checks for words that pass the checks but shouldn't
                Set<String> dangerousSWords = Set.of(
                        "integrerings", "telles", "prosents", "tredels", "års"
                );

                // If it is not in the set of problematic words, and does not appear in the dictionary or name list
                if (!dangerousSWords.contains(word) && !dictionary.containsKey(word) && !names.contains(word)) {
                    // Removes the ending s
                    String unpossessiveWord = word.substring(0, word.length() - 1);

                    // The word should now appear in one of the lists if it is a possessive. A separate function for dealing with this is called
                    if (names.contains(unpossessiveWord) || (dictionary.containsKey(unpossessiveWord))) {
                        word = RemovePossessive(unpossessiveWord, inputArray, wordIndex, dictionary, translations);
                        inputArray[wordIndex] = word;
                    }
                }
            }
            // Possessives in Bokmål comes before the noun, in Nynorsk, it comes after, and the noun changes to the lemma form
            Set<String> possessives = Set.of(
                    "min", "mi", "mitt", "din", "di", "ditt", "hans", "hennes", "vår", "vårt", "våres", "deres", "sin", "si", "sitt"
            );
            if (possessives.contains(word.toLowerCase())) {
                DelayPossessive(word, wordIndex, inputArray, dictionary);
            }
            wordIndex++;
        }

        int currentIndex = -1;
        for (String word : inputArray) {
            currentIndex++;
            boolean capital = isUpperCase(word.charAt(0)); // Keeps track of capitals for reconstruction
            /*
             Bokmål uses a synthetic passive, whereas Nynorsk uses periphrastic passive (hoppes in BM becomes blir hoppa in NN)
             If the word ends in s and is still a verb after removing the ending, further action is needed
             */
            if(word.charAt(word.length() - 1) == 's' && !word.equals("les") && !word.equals("Les") && !word.equals("felles") && !word.equals("tross")) {
                String core = word.substring(0, word.length() - 1);
                if (dictionary.containsKey(core)) {
                    if (Objects.equals(dictionary.get(core)[2], "VERB")) {

                        // Get the lemma of the BM word, translate the lemma to NN and then get the past participle version of the verb
                        String lemma = dictionary.get(core)[1];
                        String nnLemma = translations.getOrDefault(lemma.toLowerCase(), lemma);
                        String nnPeriphrastic = nnDict.getOrDefault(nnLemma.toLowerCase(), nnLemma);

                        if (capital) {
                            nnPeriphrastic = toUpperCase(nnPeriphrastic.charAt(0)) + nnPeriphrastic.substring(1);
                        }

                        // If there is a verb proceeding the synthetic passive, the auxiliary verb takes a different form
                        boolean containsVerb = false;
                            for (int i = currentIndex -1; i > 0; i -= 1) {
                                String testWord = inputArray[i];
                                if(Objects.equals(testWord, ".") || Objects.equals(testWord, ",")){
                                    break;
                                }

                                else if (dictionary.containsKey(testWord)) {
                                    if (Objects.equals(dictionary.get(testWord)[2], "VERB")) {
                                        containsVerb = true;
                                        break;
                                    }
                                }
                        }
                        if(!containsVerb){
                            nnPeriphrastic = "vert " + nnPeriphrastic;
                        }else{
                            nnPeriphrastic = "verte " + nnPeriphrastic;
                        }

                        finalSentence.append(nnPeriphrastic);
                        continue;
                    }
                }
            }

            // Checking that the article matches the noun, as sometimes Bokmål and Nynorsk differ
            if (word.equals("ein") || word.equals("ei") || word.equals("eit")) {
                for (int j = 2; j <= 4; j += 2) {
                    String nextWord = inputArray[j];
                    if (dictionary.containsKey(nextWord)) {
                        if (!Objects.equals(dictionary.get(nextWord)[3], "na")) {
                            // If the gender is equal, all is good
                            String nnGender = nnDict.get(translations.getOrDefault(nextWord, nextWord));
                            String bmGender = dictionary.get(nextWord)[3];
                            if (!Objects.equals(bmGender, nnGender)) {
                                word = switch (nnGender) {
                                    case "Masc" -> "ein";
                                    case "Fem" -> "ei";
                                    case "Neuter" -> "eit";
                                    default -> word;
                                };
                            }
                        }
                    }
                }
                finalSentence.append(word);

            } else {
                // If there is a match, it will be translated. If not, it will stay the same.
                currentWord = translations.getOrDefault(word.toLowerCase(), word);

                if (capital) {
                    currentWord = toUpperCase(currentWord.charAt(0)) + currentWord.substring(1);
                }
                finalSentence.append(currentWord);
            }
        }
            return finalSentence.toString();
        }

    // Function for reading the Nynorsk dictionary CSV
    private static HashMap<String, String> ReadNNDict() {
        HashMap<String, String> nnDict = new HashMap<>();

        try (BufferedReader reader = new BufferedReader(new FileReader("src/main/java/preprocessing/NNDictionary.csv"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }
                String[] words = line.trim().split(",");
                nnDict.put(words[0], words[3]);
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
        return nnDict;
    }

    // Function for reading the names file
    public static HashSet<String> ReadNames() {
        HashSet<String> names = new HashSet<>();


        try (BufferedReader reader = new BufferedReader(new FileReader("src/main/java/preprocessing/names.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }

                String[] words = line.trim().split("\\s+");

                for (String word : words) {
                    if (word != null && !word.isEmpty()) {
                        names.add(word);
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
        return names;
    }

    // Function for reading the bokmål dictionary CSV

    public static HashMap<String, String[]> ReadDict(){
        HashMap<String, String[]> wordList = new HashMap<>();

        try (BufferedReader reader = new BufferedReader(new FileReader("src/main/java/preprocessing/dictionary.csv"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }
                String[] words = line.trim().split(",");
                wordList.put(words[0],words);
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
        return wordList;
    }

    // Function for reading the preprocessed translations
    public static HashMap<String, String> ReadTranslations() {
        HashMap<String, String> translations = new HashMap<>();
        try (BufferedReader reader = new BufferedReader(new FileReader("src/main/java/preprocessing/translation.csv"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }
                String[] pair = line.split(",");
                translations.put(pair[0], pair[1]);
            }
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
        return translations;
    }


    /*
    Bokmål allows for possessive s. This is not legal in Nynorsk. Here, you have to use a separate possessive pronoun.
    The form of this word depends on the gender of the object it is referencing. In this function, we add the possessive
    based on the gender of the first following noun.
     */
    private static String RemovePossessive(String currentWord, String[] inputArray, int wordIndex, HashMap<String, String[]> wordList, HashMap<String, String> translations) {
        String nextWord;
        String gender = "na";

        // We loop through to find the noun. The noun is never more than a coule of positions away. By setting a limit, we ensure O(1) instead of O(n)
        for(int n = wordIndex + 1; n < inputArray.length && n <= wordIndex + 6; n++){
            nextWord = inputArray[n].toLowerCase();
            if(wordList.containsKey(nextWord)) {
                if (!Objects.equals(wordList.get(nextWord)[3], "na")) {
                    // Plural in Bokmål is marked by -er ending.The dictionary does not contain plural "gender", so there is a manual check
                    if(nextWord.endsWith("er"))
                        gender = "Pl";
                    else
                        gender = wordList.get(nextWord)[3];
                    break;
                }
            }
        }
        if(Objects.equals(gender, "Masc")){
            return translations.getOrDefault(currentWord, currentWord) + " sin";
        }
        else if(Objects.equals(gender, "Fem")){
            return translations.getOrDefault(currentWord, currentWord) + " si";
        }
        else if(Objects.equals(gender, "Neuter")){
            return translations.getOrDefault(currentWord, currentWord) + " sitt";
        }
        else if(Objects.equals(gender, "Pl")){
            return translations.getOrDefault(currentWord, currentWord) + " sine";
        }
        // If the sentence is incomplete and has no noun after the possessive, we ignore it and move on.
        else{
            return currentWord + "s";
        }
    }


    private static void DelayPossessive(String word, int wordIndex, String[] inputArray, HashMap<String, String[]> wordList){
        String noun;
        String lemma;

        if(wordIndex >= 2) {
            noun = inputArray[wordIndex - 2];
        }
        else{
            return;
        }
        String gender;

        // For delayed possessives, the noun goes to the lemma form
        if(wordList.containsKey(noun)){
            // Double-checking that the word after the possessive is a noun
            if(!Objects.equals(wordList.get(noun)[2], "NOUN")){
                return;
            }

            lemma = wordList.get(noun)[1];
            gender = wordList.get(noun)[3];

            // Bokmål has a collapsed feminine and masculine possessive pronoun. Nynorsk does not
            if(Objects.equals(word.toLowerCase(), "min") && Objects.equals(gender, "Fem")){
                word = "mi";
            }
            else if(Objects.equals(word.toLowerCase(), "din") && Objects.equals(gender, "Fem")){
                word = "di";
            }
            else if(Objects.equals(word.toLowerCase(), "sin") && Objects.equals(gender, "Fem")){
                word = "si";
            }

            // The delay of the possessive does not happen if the word preceding the noun is an adjective
            if(wordIndex >= 4 && wordList.containsKey(inputArray[wordIndex - 4])){
                if(Objects.equals(wordList.get(inputArray[wordIndex - 4])[2], "ADJ")){
                    return;
                }
            }

            inputArray[wordIndex] = lemma;
            inputArray[wordIndex - 2] = word;
        }
    }
}