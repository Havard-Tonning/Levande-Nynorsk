package com.tonning.translation.service;

import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import static java.lang.Character.isUpperCase;
import static java.lang.Character.toUpperCase;

@Service
public class TranslationService {


    public static String Translate(String input) {
        HashSet<String> names = ReadNames();
        HashMap<String, String[]> dictionary = ReadDict();
        HashMap<String, String> nnPresentPast = ReadNNDict();
        HashMap<String, String> translations = ReadTranslations();
        String currentWord;
        StringBuilder finalSentence = new StringBuilder();

        String[] inputArray = input.split("((?<=\\\\s)|(?=\\\\s))|((?<=[^a-zA-Zæøåòèê0-9])|(?=[^a-zA-Zæøåòèê0-9]))"); // Generated by Gemini

        int wordIndex = 0;
        for (String word : inputArray) {

            // If it ends in an s, it might be a possessive. To find out, we need to check if it is still a word (or name) when the s is removed
            if (word.charAt(word.length() - 1) == 's' && word.length() >= 2) {


                // We also need to check that the word is a noun, because some verbs get s-endings
                // There are also some hard coded checks for words that pass the checks but shouldn't
                Set<String> dangerousSWords = Set.of(
                        "integrerings", "telles", "prosents", "tredels", "års"
                );

                if (!dangerousSWords.contains(word) && !dictionary.containsKey(word) && !names.contains(word)) {
                    String unpossessiveWord = word.substring(0, word.length() - 1);
                    if (names.contains(unpossessiveWord) || (dictionary.containsKey(unpossessiveWord))) {
                        word = RemovePossessive(unpossessiveWord, inputArray, wordIndex, dictionary, translations);
                        inputArray[wordIndex] = word;
                    }
                }
            }
            // Possessives in Bokmål comes before the noun, in Nynorsk, it comes after, and the noun changes to the lemma form
            Set<String> possessives = Set.of(
                    "min", "mi", "mitt", "din", "di", "ditt", "hans", "hennes", "vår", "vårt", "våres", "deres", "sin", "si", "sitt"
            );
            if (possessives.contains(word.toLowerCase())) {
                DelayPossessive(word, wordIndex, inputArray, dictionary);
            }
            wordIndex++;
        }


        for (int i = 0; i < inputArray.length; i++){
            String word = inputArray[i];

            boolean capital = isUpperCase(word.charAt(0));

            // Bokmål uses a synthetic passive, whereas Nynorsk uses periphrastic passive (hoppes in BM becomes vert hoppa in NN)
            if (word.charAt(word.length() - 1) == 's' && !word.equals("les") && !word.equals("felles") && !word.equals("tross")) {
                String core = word.substring(0, word.length() - 1);
                if (dictionary.containsKey(core)) {
                    if (Objects.equals(dictionary.get(core)[2], "VERB")) {
                        // Get the lemma of the BM word, translate the lemma to NN and then get the past participle version of the verb

                        String lemma = dictionary.get(core)[1];
                        String nnLemma = translations.getOrDefault(lemma.toLowerCase(), lemma);
                        String nnPeriphrastic = nnPresentPast.getOrDefault(nnLemma.toLowerCase(),nnLemma);

                        if (capital) {
                            nnPeriphrastic = toUpperCase(nnPeriphrastic.charAt(0)) + nnPeriphrastic.substring(1);
                        }

                        nnPeriphrastic = "blir " + nnPeriphrastic;
                        finalSentence.append(nnPeriphrastic);
                        continue;
                    }
                }
            }

            if(word.equals("ein") || word.equals("ei") || word.equals("eit")){
                for(int j = 2; j <=4; j+=2) {
                    String nextWord = inputArray[j];
                    if (dictionary.containsKey(nextWord)) {
                        if(!Objects.equals(dictionary.get(nextWord)[3], "na")){
                            // If the gender is equal, all is good
                            String nnGender = nnPresentPast.get(translations.getOrDefault(nextWord, nextWord));
                            String bmGender = dictionary.get(nextWord)[3];
                            if(!Objects.equals(bmGender, nnGender)){
                                word = switch (nnGender) {
                                    case "Masc" -> "ein";
                                    case "Fem" -> "ei";
                                    case "Neuter" -> "eit";
                                    default -> word;
                                };
                            }
                        }
                    }
                }finalSentence.append(word);

            }else{
                currentWord = translations.getOrDefault(word.toLowerCase(), word); // If there is a match, it will be translated. If not, it will stay the same.

                if (capital) {
                    currentWord = toUpperCase(currentWord.charAt(0)) + currentWord.substring(1);
                }

                finalSentence.append(currentWord);
            }
        }
            return finalSentence.toString();
        }

    private static HashMap<String, String> ReadNNDict() {
        HashMap<String, String> nnDict = new HashMap<>();

        try (BufferedReader reader = new BufferedReader(new FileReader("src/main/java/preprocessing/NNDictionary.csv"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }

                String[] words = line.trim().split(",");

                nnDict.put(words[0], words[3]);
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
        return nnDict;
    }


    public static HashSet<String> ReadNames() {
        HashSet<String> names = new HashSet<>();


        try (BufferedReader reader = new BufferedReader(new FileReader("src/main/java/preprocessing/names.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }

                String[] words = line.trim().split("\\s+");

                for (String word : words) {
                    if (word != null && !word.isEmpty()) {
                        names.add(word);
                    }
                }
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
        return names;
    }

    public static HashMap<String, String[]> ReadDict(){
        HashMap<String, String[]> wordList = new HashMap<>();

        try (BufferedReader reader = new BufferedReader(new FileReader("src/main/java/preprocessing/dictionary.csv"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }

                String[] words = line.trim().split(",");

                // Technically this means that the first word will be duplicated, but it is done like this for simplicity
                wordList.put(words[0],words);
            }
        } catch (IOException e) {
            System.err.println("Error reading file: " + e.getMessage());
        }
        return wordList;
    }

    public static HashMap<String, String> ReadTranslations() {
        HashMap<String, String> translations = new HashMap<>();

        try (BufferedReader reader = new BufferedReader(new FileReader("src/main/java/preprocessing/translation.csv"))) {
            String line;

            while ((line = reader.readLine()) != null) {
                if (line.trim().isEmpty()) {
                    continue;
                }
                String[] pair = line.split(",");

                translations.put(pair[0], pair[1]);
            }
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
        return translations;
    }


    /*
    Bokmål allows for possessive s. This is not legal in Nynorsk. Here, you have to use a separate possessive pronoun.
    The form of this word depends on the gender of the object it is referencing. In this function, we add the possessive
    based on the gender of the first following noun.
     */
    private static String RemovePossessive(String currentWord, String[] inputArray, int wordIndex, HashMap<String, String[]> wordList, HashMap<String, String> translations) {
        String nextWord;
        String gender = "na";

        // We loop through to find the noun. The noun is never more than a coule of positions away. By setting a limit, we ensure O(1) instead of O(n)
        for(int n = wordIndex + 1; n < inputArray.length && n <= wordIndex + 6; n++){
            nextWord = inputArray[n].toLowerCase();
            if(wordList.containsKey(nextWord)) {
                if (!Objects.equals(wordList.get(nextWord)[3], "na")) {
                    if(nextWord.endsWith("er"))
                        gender = "Pl";
                    else
                        gender = wordList.get(nextWord)[3];
                    break;
                }
            }
        }
        if(Objects.equals(gender, "Masc")){
            return translations.getOrDefault(currentWord, currentWord) + " sin";
        }
        else if(Objects.equals(gender, "Fem")){
            return translations.getOrDefault(currentWord, currentWord) + " si";
        }
        else if(Objects.equals(gender, "Neuter")){
            return translations.getOrDefault(currentWord, currentWord) + " sitt";
        }
        else if(Objects.equals(gender, "Pl")){
            return translations.getOrDefault(currentWord, currentWord) + " sine";
        }
        // If the sentence is incomplete and has no noun after the possessive, we ignore it and move on.
        else{
            return currentWord + "s";
        }
    }


    private static void DelayPossessive(String word, int wordIndex, String[] inputArray, HashMap<String, String[]> wordList){
        String noun;
        String lemma;

        if(wordIndex >= 2) {
            noun = inputArray[wordIndex - 2];
        }
        else{
            return;
        }
        String gender;

        // For delayed possessives, the noun goes to the lemma form
        if(wordList.containsKey(noun)){
            // Double-checking that the word after the possessive is a noun
            if(!Objects.equals(wordList.get(noun)[2], "NOUN")){
                return;
            }

            lemma = wordList.get(noun)[1];
            gender = wordList.get(noun)[3];

            // Bokmål has a collapsed feminine and masculine possessive pronoun. Nynorsk does not
            if(Objects.equals(word.toLowerCase(), "min") && Objects.equals(gender, "Fem")){
                word = "mi";
            }
            else if(Objects.equals(word.toLowerCase(), "din") && Objects.equals(gender, "Fem")){
                word = "di";
            }
            else if(Objects.equals(word.toLowerCase(), "sin") && Objects.equals(gender, "Fem")){
                word = "si";
            }

            // The delay of the possessive does not happen if the word preceding the noun is an adjective
            if(wordIndex >= 4 && wordList.containsKey(inputArray[wordIndex - 4])){
                if(Objects.equals(wordList.get(inputArray[wordIndex - 4])[2], "ADJ")){
                    return;
                }
            }

            inputArray[wordIndex] = lemma;
            inputArray[wordIndex - 2] = word;
        }
    }
}